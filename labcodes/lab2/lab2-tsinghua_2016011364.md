# Lab2 实验报告

2016011364 张岱墀

## 练习1：实现 first-fit 连续物理内存分配算法

答：在`lab2/kern/mm/default_pmm.c`目录下，选择性重写了四个函数： `default_init()`, `default_init_memmap()`,

 `default_alloc_pages()`, `default_free_pages()`，以下分别说明四个函数的设计流程：

* `default_init()`函数：

```
static void default_init(void) {
    list_init(&free_list);
    nr_free = 0;
}
```

该函数主要功能为，使用`list.h`中提供的初始化方法初始化用于存下整个`free block`的`list`，然后将用于记录总共`free`的`pages`的变量设为0。

* `default_init_memmap()`函数：

```
static void default_init_memmap(struct Page *base, size_t n) {  // 初始化一块block，相当于在list的每一项下面拉链，第一页存下size
    assert(n > 0);
    struct Page *p = base;
    for (; p != base + n; p ++) {
        SetPageProperty(p);
        p->property = 0;
        set_page_ref(p, 0);
    }
    base->property = n;
    SetPageProperty(base);
    nr_free += n;
    list_add(&free_list, &(base->page_link));
}
```

初始化由`base`为起始地址，`n`为页数目的一块`free block`，主要操作为：将每一页`page`的相关`bit`位设置为指定值，然后该块的第一页的`property`成员设置为该块的总页数，然后更新`nr_free`全局变量，将该块通过`list.h`中的相关接口加入到`list`中。

* `default_alloc_pages()`函数：

```
static struct Page *default_alloc_pages(size_t n) {
    assert(n > 0);
    if (n > nr_free) {
        return NULL;
    }
    struct Page *page = NULL;
    list_entry_t *le = &free_list;
    while ((le = list_next(le)) != &free_list) {
        struct Page *p = le2page(le, page_link);
        if (p->property >= n) {
            page = p;
            break;
        }
    }
    if (page != NULL) {
        list_del(&(page->page_link));       // 先把找到的该block从list里面删掉
        if (page->property > n) {
            struct Page *p = page + n;
            p->property = page->property - n;   // 修改该block的free pages数量
            list_add(&free_list, &(p->page_link));  // 将新的block加入到list中
        }
        nr_free -= n;                       // 更新总的free pages数
        ClearPageProperty(page);            // 更新该block对应相关bit位
        SetPageReserved(page);
    }
    return page;
}
```

该函数主要功能为：在整个`free list`中寻找第一块满足`size`大于等于传入参数`n`的`block`，找到后从`list`中删除该块，将其前`n`页做上指定标记，然后取其剩下的页数重新作为一个新`block`加入到`list`中，更新相应的`property`和`nr_free`等参数。

* `default_free_pages()`函数：

```
static void default_free_pages(struct Page *base, size_t n) {
    assert(n > 0);
    // 遍历寻找并且插入新页
    list_entry_t *le = &free_list;
    struct Page *p = base;

    while ((le = list_next(le)) != &free_list) {
        p = le2page(le, page_link);
        if (base >= p && base <= le2page(list_next(le), page_link)) {
            list_add_after(&le, base);
            break;
        }
    }
    nr_free += n;

    // 相关位的重置
    p = base;
    for (; p != base + n; p ++) {
        assert(!PageReserved(p) && !PageProperty(p));
        p->flags = 0;
        set_page_ref(p, 0);
    }
    base->property = n;
    SetPageProperty(base);

    // 低地址和高地址的merge
    le = &free_list;
    while ((le = list_next(le)) != &free_list) {
        p = le2page(le, page_link);
        if (base + base->property == p) {
            base->property += p->property;
            ClearPageProperty(p);
            list_del(&(p->page_link));
        }
        else if (p + p->property == base) {
            p->property += base->property;
            ClearPageProperty(base);
            list_del(&(base->page_link));
            base = p;
        }
    }
}
```

该函数的主要功能为：对于指定的新页，首先按照地址高低遍历寻找到该页该被插入的地方，插入该页，更新全局的`nr_free`，然后和初始化类似地进行相关位的重置，最后通过再一次的遍历试图去`merge`该块周围的块。

关于以上的`first fit`算法的进一步改进空间：

* 若比较看重时间复杂度时，可以考虑在遍历整个`free list`时将简单的遍历替换为二分查找以节约时间。
* 可以考虑在输入某一个`size n`时，若找到了第一个符合条件的`block`，则另开内存记录下来这个已经搜索得到的情况，再不插入新页以及合并的前提下，若下次输入`size >= n`，则一定不会在之前找到的块之前找到目标块，通过记录已得信息来减少相应搜索范围。



## 练习2：实现寻找虚拟地址对应的页表项

答：



## 练习3：释放某虚拟地址所在页并取消对应二级页表项的映射

答：